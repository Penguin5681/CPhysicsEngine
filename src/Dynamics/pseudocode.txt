CLASS RigidBody:
    // ... existing properties ...
    float restitution;

    // --- NEW FRICTION Properties ---
PUBLIC:
    float staticFriction;
    float dynamicFriction; // Also called kinetic friction

PUBLIC:
    // CONSTRUCTOR
    RigidBody() :
        // ... existing initializers ...
        restitution(0.5f), // Example value
        staticFriction(0.6f), // Example value (e.g., rubber on concrete)
        dynamicFriction(0.5f) // Example value (kinetic < static)
    {}

    // ... rest of RigidBody ...



    ---


    PRIVATE:
      FUNCTION void resolveCollisions()
          FOR EACH manifold IN collisions:
              IF manifold.numContactPoints == 0 THEN CONTINUE;

              RigidBody* A = manifold.bodyA;
              RigidBody* B = manifold.bodyB;
              Vector3 normal = manifold.contactNormal;
              float penetration = manifold.penetrationDepth;

              // Combine friction properties (e.g., average or multiply)
              float staticFriction = (A->staticFriction + B->staticFriction) * 0.5f;
              float dynamicFriction = (A->dynamicFriction + B->dynamicFriction) * 0.5f;

              // --- Wake/Sleep checks (as before) ---
              // ...

              // --- Iterate through contact points ---
              FOR i FROM 0 TO manifold.numContactPoints - 1:
                  Vector3 contactPoint = manifold.contactPoints[i];
                  Vector3 rA = contactPoint - A->position;
                  Vector3 rB = contactPoint - B->position;

                  // --- Resolve Normal Impulse (as before) ---
                  Vector3 velA = A->velocity + A->angularVelocity.cross(rA);
                  Vector3 velB = B->velocity + B->angularVelocity.cross(rB);
                  Vector3 relVel = velB - velA;
                  float velAlongNormal = relVel.dot(normal);

                  // Apply restitution impulse only if separating velocity is significant enough
                  // (Helps prevent jitter when objects are almost resting)
                  float restitutionBias = 0.0f; // Could add a small velocity bias here if needed
                  float e = std::min(A->restitution, B->restitution);
                  float j_n = 0.0f; // Normal impulse magnitude

                  IF velAlongNormal < -restitutionBias THEN // Check if objects are colliding
                      // Calculate normal impulse 'j_n' (denominator includes rotational terms)
                      Vector3 termA = (A->inverseInertiaTensor.transform(rA.cross(normal))).cross(rA);
                      Vector3 termB = (B->inverseInertiaTensor.transform(rB.cross(normal))).cross(rB);
                      float denominator = A->inverseMass + B->inverseMass + (termA + termB).dot(normal);

                      IF denominator > 0.0001f THEN // Avoid division by zero
                          j_n = -(1.0f + e) * velAlongNormal / denominator;
                          // --- Apply Normal Impulse ---
                          Vector3 impulseN = normal * j_n;
                          A->velocity -= impulseN * A->inverseMass;
                          B->velocity += impulseN * B->inverseMass;
                          A->angularVelocity += A->inverseInertiaTensor.transform(rA.cross(impulseN) * -1.0f);
                          B->angularVelocity += B->inverseInertiaTensor.transform(rB.cross(impulseN));
                      END IF
                  END IF

                  // --- Resolve Tangential (Friction) Impulse ---
                  // Recalculate relative velocity *after* normal impulse is applied
                  velA = A->velocity + A->angularVelocity.cross(rA);
                  velB = B->velocity + B->angularVelocity.cross(rB);
                  relVel = velB - velA;

                  // Calculate tangential velocity
                  Vector3 tangentVel = relVel - normal * relVel.dot(normal);
                  float tangentSpeedSq = tangentVel.magnitudeSquared();

                  IF tangentSpeedSq > 0.0001f THEN // If there is tangential motion
                      Vector3 tangentDir = tangentVel / std::sqrt(tangentSpeedSq); // Normalized direction of sliding

                      // Calculate impulse needed to stop sliding along this tangent
                      Vector3 termA_t = (A->inverseInertiaTensor.transform(rA.cross(tangentDir))).cross(rA);
                      Vector3 termB_t = (B->inverseInertiaTensor.transform(rB.cross(tangentDir))).cross(rB);
                      float denominator_t = A->inverseMass + B->inverseMass + (termA_t + termB_t).dot(tangentDir);

                      IF denominator_t > 0.0001f THEN
                          float jt_mag_needed = -relVel.dot(tangentDir) / denominator_t; // Impulse magnitude needed

                          // Clamp friction impulse using Coulomb model
                          float frictionLimit = staticFriction * std::abs(j_n); // Max static friction impulse
                          float jt_mag_clamped = std::max(-frictionLimit, std::min(jt_mag_needed, frictionLimit));

                          // --- Apply Friction Impulse ---
                          Vector3 impulseT = tangentDir * jt_mag_clamped;
                          A->velocity -= impulseT * A->inverseMass;
                          B->velocity += impulseT * B->inverseMass;
                          A->angularVelocity += A->inverseInertiaTensor.transform(rA.cross(impulseT) * -1.0f);
                          B->angularVelocity += B->inverseInertiaTensor.transform(rB.cross(impulseT));
                      END IF
                  END IF
              END FOR // End loop through contact points

              // --- Positional Correction (Applied ONCE, as before) ---
              // ...
          END FOR // End loop through manifolds
      END FUNCTION