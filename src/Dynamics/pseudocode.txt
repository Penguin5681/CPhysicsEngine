CLASS Matrix3x3:
    // ... all existing code ...

    // --- NEW HELPER FUNCTION ---
    // Transforms a vector as if by the transpose of this matrix.
    [[nodiscard]] FUNCTION Vector3 transformTranspose(const Vector3& vector) const
        // M^T * v
        RETURN Vector3(
            data[0] * vector.x + data[3] * vector.y + data[6] * vector.z, // row 0
            data[1] * vector.x + data[4] * vector.y + data[7] * vector.z, // row 1
            data[2] * vector.x + data[5] * vector.y + data[8] * vector.z  // row 2
        );
    END FUNCTION

    // PhyWORLD



    // This is inside the PhysicsWorld class

    PRIVATE:
      // We will also need a <cmath> include for std::min/max
      // if it's not already there.

      // --- NEW HELPER FUNCTION: Clamp ---
      // A simple helper to clamp a value between a min and max
      FUNCTION float clamp(float value, float minVal, float maxVal)
          RETURN std::max(minVal, std::min(value, maxVal));
      END FUNCTION


      // --- IMPLEMENTING THE STUB ---
      FUNCTION void checkSphereBox(RigidBody* sphereBody, RigidBody* boxBody)
          // 1. Get the shapes
          BoundingSphere* sphere = (BoundingSphere*)sphereBody->shape;
          BoundingBox* box = (BoundingBox*)boxBody->shape;

          // 2. Transform sphere center into box's local space
          Vector3 sphereCenterWorld = sphereBody->position;
          Vector3 sphereCenterLocal = boxBody->rotationMatrix.transformTranspose(
              sphereCenterWorld - boxBody->position
          );

          // 3. Find the closest point on the AABB (in local space)
          // by clamping the local sphere center to the box's half-extents.
          Vector3 closestPointLocal;
          closestPointLocal.x = clamp(sphereCenterLocal.x, -box->halfExtents.x, box->halfExtents.x);
          closestPointLocal.y = clamp(sphereCenterLocal.y, -box->halfExtents.y, box->halfExtents.y);
          closestPointLocal.z = clamp(sphereCenterLocal.z, -box->halfExtents.z, box->halfExtents.z);

          // 4. Transform the local closest point back into world space
          Vector3 closestPointWorld = boxBody->rotationMatrix.transform(closestPointLocal) + boxBody->position;

          // 5. Now we just do a simple sphere-vs-point check
          Vector3 dir = sphereCenterWorld - closestPointWorld;
          float distanceSquared = dir.magnitudeSquared();
          float radiusSquared = sphere->radius * sphere->radius;

          IF distanceSquared < radiusSquared:
              // We have a collision!
              float distance = std::sqrt(distanceSquared);
              Vector3 normal = (distance > 0.0f) ? dir / distance : Vector3(0, 1, 0);
              float penetration = sphere->radius - distance;
              Vector3 contactPoint = closestPointWorld; // The contact point *is* the closest point

              // Add the manifold
              // Note: The normal must point from A (sphere) to B (box)
              // Our 'dir' is (sphere - box), so the normal is already correct.
              collisions.push_back(CollisionManifold(sphereBody, boxBody, normal, penetration, contactPoint));
          END IF
      END FUNCTION