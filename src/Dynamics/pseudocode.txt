CLASS PhysicsWorld:
    // ... all existing code ...

    // MODIFIED: detectCollisions() must now calculate the contact point
    PRIVATE:
        FUNCTION void detectCollisions()
            // ... in the N-squared loop ...
            IF dist < totalRadius:
                // ... normal and penetration ...

                // NEW: Calculate contact point
                // For two spheres, it's halfway between them along the collision normal
                DEFINE Vector3 contact = body1->position + normal * (body1->shape->radius - penetration / 2.0f)

                collisions.push_back(CollisionManifold(body1, body2, normal, penetration, contact))
                // ... print statement ...
            END IF
        END FUNCTION

    // HEAVILY MODIFIED: The full, correct impulse resolution
    PRIVATE:
        FUNCTION void resolveCollisions()
            FOR EACH manifold IN collisions:
                RigidBody* A = manifold.bodyA
                RigidBody* B = manifold.bodyB
                Vector3 normal = manifold.contactNormal
                Vector3 contactPoint = manifold.contactPoint

                // --- (1) Calculate all the vectors from center of mass to contact point ---
                DEFINE Vector3 rA = contactPoint - A->position
                DEFINE Vector3 rB = contactPoint - B->position

                // --- (2) Calculate relative velocity AT THE CONTACT POINT ---
                // v = v_linear + v_angular
                // v_angular = angularVelocity x r
                DEFINE Vector3 velA = A->velocity + A->angularVelocity.cross(rA)
                DEFINE Vector3 velB = B->velocity + B->angularVelocity.cross(rB)
                DEFINE Vector3 relVel = velB - velA

                // ... (as before) ...
                DEFINE float velAlongNormal = relVel.dot(normal)
                IF velAlongNormal > 0.0 THEN CONTINUE
                DEFINE float e = min(A->restitution, B->restitution)

                // --- (3) The FULL impulse formula (with rotation) ---
                // This is the hardest part of any physics engine.

                // a) Calculate the rotational "mass" part
                DEFINE Vector3 termA = (A->inverseInertiaTensor.transform(rA.cross(normal))).cross(rA)
                DEFINE Vector3 termB = (B->inverseInertiaTensor.transform(rB.cross(normal))).cross(rB)

                // b) The full denominator
                DEFINE float denominator = A->inverseMass + B->inverseMass + (termA + termB).dot(normal)

                // c) Calculate the impulse scalar j
                DEFINE float j = -(1.0f + e) * velAlongNormal
                j /= denominator // <-- THIS IS THE FIX FOR THE "SUPER-BOUNCE"

                // --- (4) Apply linear AND angular impulse ---
                DEFINE Vector3 impulse = normal * j
                A->velocity -= impulse * A->inverseMass
                A->addTorque(-(rA.cross(impulse))) // Apply angular impulse

                B->velocity += impulse * B->inverseMass
                B->addTorque(rB.cross(impulse)) // Apply angular impulse

                // --- (5) Positional Correction (The "Sinking" fix) ---
                // We push the objects apart based on penetration depth
                DEFINE float percent = 0.2f // Usually 20-80%
                DEFINE float slop = 0.01f  // A small buffer
                DEFINE Vector3 correction = normal * (max(penetration - slop, 0.0f) / (A->inverseMass + B->inverseMass)) * percent

                A->position -= correction * A->inverseMass
                B->position += correction * B->inverseMass
            END FOR
        END FUNCTION