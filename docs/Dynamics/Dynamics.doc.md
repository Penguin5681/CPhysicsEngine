# Physics Dynamics System Documentation

This document provides a comprehensive overview of the rigid body dynamics system implemented in the CPhysicsEngine. The system simulates both linear and angular motion of rigid bodies under forces and torques.

## Overall Architecture

The dynamics system consists of:
1. `RigidBody` class - Represents individual physical objects
2. `PhysicsWorld` class - Manages all bodies and their interactions

## Rigid Body Dynamics

A rigid body is a solid object where the distance between any two points on the body remains constant, regardless of external forces. The simulation tracks both linear and angular properties.

### Linear Motion Properties

- **Position** ($\vec{p}$): The location of the body's center of mass in world space
- **Linear Velocity** ($\vec{v}$): The rate of change of position
- **Linear Acceleration** ($\vec{a}$): The rate of change of linear velocity
- **Force** ($\vec{F}$): Accumulated forces applied to the body
- **Inverse Mass** ($m^{-1}$): 1/mass of the body (0 for immovable objects)

### Rotational Motion Properties

- **Orientation** ($q$): Quaternion representing the body's rotation
- **Angular Velocity** ($\vec{\omega}$): The rate of change of orientation
- **Angular Acceleration** ($\vec{\alpha}$): The rate of change of angular velocity
- **Torque** ($\vec{\tau}$): Accumulated torques applied to the body
- **Inverse Inertia Tensor** ($I^{-1}$): A 3Ã—3 matrix representing the body's resistance to rotation

### Motion Equations

#### Linear Motion

Linear motion follows Newton's laws of motion:

$$\vec{F} = m\vec{a}$$

For numerical integration, using semi-implicit Euler method:
$$\vec{a} = \vec{F} \times m^{-1}$$
$$\vec{v}_{new} = \vec{v}_{old} + \vec{a} \times \Delta t$$
$$\vec{p}_{new} = \vec{p}_{old} + \vec{v}_{new} \times \Delta t$$

#### Rotational Motion

Angular motion uses the following equations:

$$\vec{\tau} = I\vec{\alpha}$$

For numerical integration:
$$\vec{\alpha} = I^{-1} \times \vec{\tau}$$
$$\vec{\omega}_{new} = \vec{\omega}_{old} + \vec{\alpha} \times \Delta t$$

The orientation quaternion $q$ is updated using:
$$q_{new} = q_{old} + \frac{1}{2}(q_{old} \times [0, \vec{\omega}_{new}]) \times \Delta t$$

Where $[0, \vec{\omega}_{new}]$ is a quaternion with scalar part 0 and vector part $\vec{\omega}_{new}$.

For numerical stability, the quaternion should be normalized after each integration step.

### Inertia Tensor

The inertia tensor defines how mass is distributed and affects rotational dynamics. For a cuboid with dimensions $(w, h, d)$ and mass $m$:

$$I_x = \frac{1}{12}m(h^2 + d^2)$$
$$I_y = \frac{1}{12}m(w^2 + d^2)$$
$$I_z = \frac{1}{12}m(w^2 + h^2)$$

The inertia tensor in the body's local space for an axis-aligned cuboid is:

$$I_{body} = 
\begin{bmatrix} 
I_x & 0 & 0 \\
0 & I_y & 0 \\
0 & 0 & I_z 
\end{bmatrix}$$

As the body rotates, the inertia tensor in world space must be recalculated:

$$I_{world} = R \times I_{body} \times R^T$$

Where $R$ is the rotation matrix derived from the body's orientation quaternion.

## Force and Torque Application

### Linear Forces

Forces act on the center of mass and affect linear motion:

$$\vec{F}_{total} = \sum \vec{F}_i$$

### Torques

Torques are generated by forces applied away from the center of mass:

$$\vec{\tau} = \vec{r} \times \vec{F}$$

Where $\vec{r}$ is the vector from the center of mass to the point of force application.

## The Simulation Loop

The physics simulation follows these steps for each time step:

1. Clear accumulated forces and torques
2. Apply external forces (gravity, user forces, etc.)
3. Detect and resolve collisions (generating additional forces)
4. Integrate motion equations to update positions and orientations
5. Update derived data (world inertia tensor, etc.)

## Implementation Notes

### Handling Immovable Objects

Bodies with `inverseMass = 0` are treated as having infinite mass and do not respond to forces.

### Numerical Stability

- Use appropriate time steps to prevent numerical instability
- Consider using a more sophisticated integrator for better accuracy (e.g., Runge-Kutta)
- Implement energy dampening to prevent perpetual motion

## Usage Example

```cpp
// Create physics world with gravity
PhysicsWorld world(Vector3(0, -9.81, 0));

// Create a rigid body
RigidBody* body = new RigidBody();
body->inverseMass = 0.1f;  // Mass of 10
body->position = Vector3(0, 10, 0);

// Set up inertia tensor for a cuboid
Matrix3x3 inertiaTensor;
inertiaTensor.setInverseInertiaTensorCuboid(10.0f, Vector3(2.0f, 1.0f, 3.0f));
body->setInverseInertiaTensor(inertiaTensor);

// Add body to world
world.addBody(body);

// Run simulation
float timeStep = 0.016f;  // 60fps
while (simulationRunning) {
    world.step(timeStep);
    // Update graphics
}
```
